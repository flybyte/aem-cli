import path from "path";import { Option } from "commander";import chalk from "chalk";import Mustache from "mustache";import { Constants } from "../constants.js";import {    checkIfContainerEngineAvailable,    checkIfFilesExist,    hideDeprecationWarnings,    printErrorAndExit,    fetchResourceAsText,    options2data,    createFolder,    writeTextToFile,} from "../helper.js";import * as helper from "../helper.js";const { white } = chalk;export const initCommand = (program) => {    const cmd = program.command("init").description("Initialize local AEM dev environment");    cmd.addOption(new Option("-a, --author       <string>", "the ports used for the author container").default("4502,14502,24502"));    cmd.addOption(new Option("-d, --domain       <string>", "local domain without subdomain").default("aem.local"));    cmd.addOption(new Option("-e, --engine       <string>", "which container engine to use").default("podman").choices(["podman", "docker"]));    cmd.addOption(new Option("-f, --force", "required to overwrite existing files").default(false));    cmd.addOption(new Option("-i, --image        <string>", "the name of the registry and namespace for the container (example: 'ghcr.io/flybyte')").makeOptionMandatory(true));    cmd.addOption(new Option("-l, --mail         <string>", "the ports used for the mail container").default("4025,4090"));    cmd.addOption(new Option("-m, --maven        <string>", "the path to the Maven project").makeOptionMandatory(true));    cmd.addOption(new Option("-n, --name         <string>", "name of the project in podman/docker compose").default("aemdev"));    cmd.addOption(new Option("-o, --hosts", "when present will add/update entries to local hosts file").default(false));    cmd.addOption(new Option("-p, --publish      <string>", "the ports used for the publish container").default("4503,14503,24503"));    cmd.addOption(new Option("-r, --dispatcher   <string>", "the port used for the dispatcher container").default("8080"));    cmd.addOption(new Option("-t, --tag          <string>", "the tag of the container images").default("latest"));    cmd.addOption(new Option("-x, --proxy        <string>", "the ports to the proxy container").default("80,443"));    cmd.addOption(new Option("-z, --timezone     <string>", "the timezone of the container images").default("Europe/Zurich"));    cmd.action((options) => {        helper.hideDeprecationWarnings();        //hideDeprecationWarnings();        checkIfContainerEngineAvailable();        checkIfProceed(options);        createFolders();        createLocalFiles(options);        // TODO download files        // TODO print message how to proceed    });};const checkIfProceed = (options) => {    const curDir = process.cwd();    const envPath = path.join(curDir, ".env");    const composePath = path.join(curDir, "compose.yml");    const volumePath = path.join(curDir, "volumes");    const authorPath = path.join(volumePath, "author");    const publishPath = path.join(volumePath, "publish");    const dispatcherPath = path.join(volumePath, "dispatcher");    const proxyPath = path.join(volumePath, "proxy");    const backupPath = path.join(curDir, "backups");    const pathsToCheck = [envPath, composePath, volumePath, authorPath, publishPath, dispatcherPath, proxyPath, backupPath];    const { existing } = checkIfFilesExist(pathsToCheck);    if (existing.length > 0 && !options.force) {        printErrorAndExit(`Required resources already exits. Use ${white("--force")} to proceed and forcefully overwrite existing resources.`, 5);    }    if (options.author.split(",").length !== 3) {        printErrorAndExit(`${white("--author")} option has wrong format, requires ${white("3 port numbers")} seperated by comma (e.g. 4502,14502,24502): ${options.author}`, 6);    }    if (options.publish.split(",").length !== 3) {        printErrorAndExit(`${white("--publish")} option has wrong format, requires ${white("3 port numbers")} seperated by comma (e.g. 4503,14503,24503): ${options.publish}`, 6);    }    if (options.proxy.split(",").length !== 2) {        printErrorAndExit(`${white("--proxy")} option has wrong format, requires ${white("2 port numbers")} seperated by comma (e.g. 80,443): ${options.proxy}`, 6);    }    if (options.mail.split(",").length !== 2) {        printErrorAndExit(`${white("--mail")} option has wrong format, requires ${white("2 port numbers")} seperated by comma (e.g. 4025,4090): ${options.mail}`, 6);    }};const createFolders = () => {    const curDir = process.cwd();    createFolder(path.join(curDir, Constants.folder.backups));    createFolder(path.join(curDir, Constants.folder.volumes, "author", "install"));    createFolder(path.join(curDir, Constants.folder.volumes, "author", "logs"));    createFolder(path.join(curDir, Constants.folder.volumes, "publish", "install"));    createFolder(path.join(curDir, Constants.folder.volumes, "publish", "logs"));    createFolder(path.join(curDir, Constants.folder.volumes, "dispatcher", "cache"));    createFolder(path.join(curDir, Constants.folder.volumes, "dispatcher", "logs"));    createFolder(path.join(curDir, Constants.folder.volumes, "proxy", "conf.d"));    createFolder(path.join(curDir, Constants.folder.volumes, "proxy", "html"));    createFolder(path.join(curDir, Constants.folder.volumes, "proxy", "ssl"));    createFolder(path.join(curDir, Constants.folder.volumes, "author", "install"));    createFolder(path.join(curDir, Constants.folder.volumes, "author", "logs"));    createFolder(path.join(curDir, Constants.folder.volumes, "publish", "install"));    createFolder(path.join(curDir, Constants.folder.volumes, "publish", "logs"));    createFolder(path.join(curDir, Constants.folder.volumes, "dispatcher", "cache"));    createFolder(path.join(curDir, Constants.folder.volumes, "dispatcher", "logs"));    createFolder(path.join(curDir, Constants.folder.volumes, "proxy", "conf.d"));    createFolder(path.join(curDir, Constants.folder.volumes, "proxy", "html"));    createFolder(path.join(curDir, Constants.folder.volumes, "proxy", "ssl"));};const createLocalFiles = async (options) => {    const curDir = process.cwd();    const data = options2data(options);    const envTpl = await fetchResourceAsText(Constants.templates.env);    const envContent = Mustache.render(envTpl, data);    writeTextToFile(path.join(curDir, ".env"), envContent);    const compose = await fetchResourceAsText(Constants.templates.compose);    writeTextToFile(path.join(curDir, "compose.yml"), compose);    // TODO readme};